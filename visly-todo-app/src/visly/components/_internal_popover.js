// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, { useRef, useState, useEffect } from "react";
import { createPortal } from "react-dom";
import {
  exists,
  useRect,
  useEventHandlers,
  useRootProps,
  combineRef,
  getStyleFunc,
} from "./_internal_utils";
import { Gravity, gravityStringToEnum } from "./_internal_tooltip";
export let Alignment;

(function (Alignment) {
  Alignment[(Alignment["Start"] = 0)] = "Start";
  Alignment[(Alignment["Center"] = 1)] = "Center";
  Alignment[(Alignment["End"] = 2)] = "End";
})(Alignment || (Alignment = {}));

function alignmentStringToEnum(align) {
  return align === "start"
    ? Alignment.Start
    : align === "center"
    ? Alignment.Center
    : align === "end"
    ? Alignment.End
    : Alignment.Start;
}

const width = (rect) => {
  return rect.right - rect.left;
};

const height = (rect) => {
  return rect.bottom - rect.top;
};

export const DefaultPopoverPositions = {
  under: {
    gravity: Gravity.Bottom,
    align: Alignment.Start,
    gravityOffset: 0,
    alignOffset: 0,
  },
};

function layout(anchorRect, childRect, strategy) {
  const { gravity, align, gravityOffset = 0, alignOffset = 0 } = strategy;
  let x, y;

  const calcAlignmentX = () => {
    switch (align) {
      case Alignment.Start:
        return anchorRect.left + alignOffset;

      case Alignment.Center:
        return (
          anchorRect.left +
          width(anchorRect) / 2 -
          width(childRect) / 2 +
          alignOffset
        );

      case Alignment.End:
        return (
          anchorRect.left + width(anchorRect) - width(childRect) - alignOffset
        );
    }
  };

  const calcAlignmentY = () => {
    switch (align) {
      case Alignment.Start:
        return anchorRect.top + alignOffset;

      case Alignment.Center:
        return (
          anchorRect.top +
          height(anchorRect) / 2 -
          height(childRect) / 2 +
          alignOffset
        );

      case Alignment.End:
        return (
          anchorRect.top + height(anchorRect) - height(childRect) - alignOffset
        );
    }
  };

  switch (gravity) {
    case Gravity.Top:
      x = calcAlignmentX();
      y = anchorRect.top - height(childRect) - gravityOffset;
      break;

    case Gravity.Bottom:
      x = calcAlignmentX();
      y = anchorRect.top + height(anchorRect) + gravityOffset;
      break;

    case Gravity.Left:
      x = anchorRect.left - width(childRect) - gravityOffset;
      y = calcAlignmentY();
      break;

    case Gravity.Right:
      x = anchorRect.left + width(anchorRect) + gravityOffset;
      y = calcAlignmentY();
      break;
  }

  return {
    left: x,
    right: x + width(childRect),
    top: y,
    bottom: y + height(childRect),
  };
}

const testLayout = (parent, child) => {
  return (
    parent.left <= child.left &&
    parent.top <= child.top &&
    parent.right >= child.right &&
    parent.bottom >= child.bottom
  );
};

function fit(parent, child) {
  const left = width(child) >= width(parent) ? 0 : child.left;
  const top = height(child) >= height(parent) ? 0 : child.top;
  return {
    left: left,
    top: top,
    right: left + width(child),
    bottom: top + height(child),
  };
}

function inverseGravity(gravity) {
  return gravity === Gravity.Top
    ? Gravity.Bottom
    : gravity === Gravity.Bottom
    ? Gravity.Top
    : gravity === Gravity.Left
    ? Gravity.Right
    : gravity === Gravity.Right
    ? Gravity.Left
    : undefined;
}

function findOrderedRefitStrategies({ gravity, align }) {
  const gravities = Object.keys(Gravity)
    .filter((key) => !isNaN(Number(Gravity[key])))
    .map((k) => Gravity[k]);
  const alignments = Object.keys(Alignment)
    .filter((key) => !isNaN(Number(Alignment[key])))
    .map((k) => Alignment[k]);
  const otherAlignments = alignments.filter((a) => a !== align);
  return [
    [gravity, align],
    ...otherAlignments.map((a) => [gravity, a]),
    [inverseGravity(gravity), align],
    ...otherAlignments.map((a) => [inverseGravity(gravity), a]),
    ...gravities
      .filter((g) => g !== gravity && g !== inverseGravity(gravity))
      .map((g) => alignments.map((a) => [g, a]))
      .flat(),
  ];
}

export function layoutPopover({
  windowRect,
  anchorRect,
  popoverRect,
  strategy,
}) {
  let fits = false;
  let popover = null;
  let usedStrategy = strategy;
  const refitStrategies = findOrderedRefitStrategies(strategy);

  for (const refit of refitStrategies) {
    const [gravity, align] = refit;
    usedStrategy = { ...strategy, gravity, align };
    popover = layout(anchorRect, popoverRect, usedStrategy);
    fits = testLayout(windowRect, popover);

    if (fits) {
      break;
    }
  }

  if (!fits) {
    return [
      fit(windowRect, layout(anchorRect, popoverRect, strategy)),
      strategy,
    ];
  }

  return [popover, usedStrategy];
}
export function getPopoverPosition(targetRect, popoverRect, strategy) {
  const windowRect = {
    left: 0,
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
  };

  const simpleRect = (rect) => ({
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height,
  });

  return layoutPopover({
    windowRect,
    anchorRect: simpleRect(targetRect),
    popoverRect: simpleRect(popoverRect),
    strategy,
  });
}

function Popover(props) {
  const popoverRef = useRef();
  const popoverRect = useRect(popoverRef, true);
  const [popoverPosition, setPopoverPosition] = useState(null);
  useEffect(() => {
    setPopoverPosition((prev) => {
      if (!exists(prev)) {
        return getPopoverPosition(
          props.targetRect,
          popoverRect,
          exists(props.position)
            ? props.position
            : DefaultPopoverPositions.under
        );
      }

      const [, strategy] = prev;
      return getPopoverPosition(props.targetRect, popoverRect, strategy);
    });
  }, [popoverRect, props.targetRect, props.position]);
  const [rect] = exists(popoverPosition) ? popoverPosition : [null];
  return (
    <div
      style={{
        display: "flex",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
      }}
      onClick={(e) => {
        e.stopPropagation();
        props.onClose();
      }}
    >
      {exists(rect) ? (
        <div
          style={{
            position: "absolute",
            left: rect.left,
            top: rect.top,
          }}
          onClick={(e) => e.stopPropagation()}
          ref={popoverRef}
        >
          {props.popover}
        </div>
      ) : null}
    </div>
  );
}

export function PopoverRoot(props) {
  const ref = useRef();
  const { state } = useEventHandlers({
    ref,
    ...props,
  });
  const {
    style,
    injectedProps,
    className,
    tabIndex,
    testId,
    innerRef,
    role,
    values,
  } = useRootProps(props, state);
  const targetRect = useRect(props.targetRef, true);
  const Content = (
    <div
      tabIndex={tabIndex}
      ref={combineRef(innerRef, ref)}
      role={role}
      data-testid={testId}
      {...(exists(injectedProps.reactProps) ? injectedProps.reactProps : {})}
      className={className}
      style={style}
    >
      {props.children(getStyleFunc(values))}
    </div>
  );

  if (props.showInline) {
    return Content;
  }

  return props.isOpen
    ? createPortal(
        <Popover
          targetRect={targetRect}
          popover={Content}
          position={{
            gravity: gravityStringToEnum(props.gravity),
            align: alignmentStringToEnum(props.align),
            gravityOffset: props.gravityOffset,
            alignOffset: props.alignOffset,
          }}
          onClose={props.onClose}
        />,
        document.body
      )
    : null;
}
