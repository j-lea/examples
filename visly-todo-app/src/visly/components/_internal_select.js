// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, {
  createContext,
  useContext,
  useRef,
  useState,
  useEffect,
  useCallback,
} from "react";
import { createPortal } from "react-dom";
import {
  useEventHandlers,
  combineRef,
  useRootProps,
  exists,
  InteractionState,
  useRect,
  noop,
  renderChildren,
} from "./_internal_utils";
import { Popover, Alignment } from "./_internal_popover";
import { Gravity } from "./_internal_tooltip";
import { mergeHotkeys, useHotkey } from "./_internal_utils_hotkeys";
import {
  DescendantsProvider,
  useDescendant,
} from "./_internal_utils_descendants";
import { useSpacing } from "./_internal_component_utils";
const SelectContext = createContext(null);
export function SelectOptionContainer(props) {
  const {
    isOpen,
    setIsOpen,
    targetRect,
    rootClassName,
    focusedOption,
    menuRef,
  } = useContext(SelectContext);
  const ref = useRef(null);
  useEffect(() => {
    if (exists(ref.current)) {
      ref.current.focus();
    }
  }, [ref.current]);
  const children = useSpacing(props.addSpacing, props.children);
  return isOpen
    ? createPortal(
        <Popover
          targetRect={targetRect}
          popover={
            <div key={props.innerKey} className={rootClassName}>
              {exists(props.cssStyles) ? (
                <style
                  style={{
                    display: "none",
                  }}
                >
                  {props.cssStyles}
                </style>
              ) : null}
              <div
                ref={combineRef(ref, menuRef)}
                role="listbox"
                aria-activedescendant={`option-${focusedOption}`}
                tabIndex={-1}
                className={props.className}
                style={{
                  overflow: "auto",
                }}
                onBlur={() => setIsOpen(false)}
              >
                {children}
              </div>
            </div>
          }
          position={{
            gravity: Gravity.Bottom,
            align: Alignment.Start,
            gravityOffset: 10,
            alignOffset: 0,
          }}
          onClose={() => setIsOpen(false)}
        />,
        document.body
      )
    : null;
}
export function SelectButton(props) {
  const { isOpen, setIsOpen, buttonRef, disabled } = useContext(SelectContext);
  return (
    <button
      ref={buttonRef}
      className={props.className}
      aria-haspopup="listbox"
      aria-expanded={isOpen || undefined}
      onClick={disabled ? noop : () => setIsOpen(true)}
    >
      {props.children}
    </button>
  );
}
export function SelectRoot(props) {
  const ref = useRef();
  const { selected, onSelect } = props;
  const { state, handlers } = useEventHandlers({
    ref,
    ...props,
  });
  const {
    style,
    injectedProps,
    className,
    tabIndex,
    testId,
    innerRef,
    role,
    values,
  } = useRootProps(props, state);
  const noSelectStyles = {
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const buttonRef = useRef(null);
  const menuRef = useRef(null);
  const targetRect = useRect(buttonRef, true);
  const menuRect = useRect(menuRef, true);
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState([]);
  const [focusedOption, setFocusedOption] = useState(0);
  const disabled = state === InteractionState.Disabled;
  const selectAndClose = useCallback(
    (value) => {
      if (exists(onSelect)) {
        onSelect(value);
      }

      setIsOpen(false);
      const item = items.find((d) => d.value === value);
      setFocusedOption(exists(item) ? item.index : null);
      buttonRef.current.focus();
    },
    [items, onSelect]
  );
  const focusPrevious = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      setFocusedOption((cur) => {
        if (!exists(cur)) {
          return null;
        }

        let newItem = items[cur];
        let newIdx = cur;

        while ((newIdx === cur || newItem.disabled) && newIdx !== 0) {
          newItem = items[--newIdx];
        }

        return newItem.disabled ? cur : newIdx;
      });
    }
  }, [isOpen, items]);
  const focusNext = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      setFocusedOption((cur) => {
        if (!exists(cur)) {
          return null;
        }

        let newItem = items[cur];
        let newIdx = cur;

        while (
          (newIdx === cur || newItem.disabled) &&
          newIdx !== items.length - 1
        ) {
          newItem = items[++newIdx];
        }

        return newItem.disabled ? cur : newIdx;
      });
    }
  }, [isOpen, items]);
  const selectItem = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      const item = items.find((d) => d.index === focusedOption);
      selectAndClose(item.value);
    }
  }, [items, focusedOption, isOpen, selectAndClose]);
  const hotkeys = mergeHotkeys([
    useHotkey(
      {
        key: "arrowup",
        allowInput: true,
        disabled,
      },
      focusPrevious
    ),
    useHotkey(
      {
        key: "arrowdown",
        allowInput: true,
        disabled,
      },
      focusNext
    ),
    useHotkey(
      {
        key: "enter",
        allowInput: true,
        disabled,
      },
      selectItem
    ),
    useHotkey(
      {
        key: "escape",
        allowInput: true,
        disabled,
      },
      () => setIsOpen(false)
    ),
  ]);

  const onKeyUp = (e) => {
    if (exists(handlers.onKeyUp)) {
      handlers.onKeyUp(e);
    }

    hotkeys.onKeyUp(e);
  };

  const onKeyDown = (e) => {
    if (exists(handlers.onKeyDown)) {
      handlers.onKeyDown(e);
    }

    hotkeys.onKeyDown(e);
  };

  useEffect(() => {
    if (exists(selected)) {
      const selectedDescendant = items.find((d) => d.value === selected);

      if (exists(selectedDescendant)) {
        setFocusedOption(selectedDescendant.index);
      }
    }
  }, [items, selected]);
  const delegateFocusToButton = useCallback(
    (e) => {
      if (exists(buttonRef.current) && !isOpen) {
        buttonRef.current.focus();
      }

      if (exists(handlers.onFocus)) {
        handlers.onFocus(e);
      }
    },
    [handlers, isOpen]
  );
  return (
    <div
      tabIndex={exists(tabIndex) ? tabIndex : 0}
      ref={combineRef(innerRef, ref)}
      role={role}
      data-testid={testId}
      {...handlers}
      onFocus={disabled ? noop : delegateFocusToButton}
      onKeyUp={onKeyUp}
      onKeyDown={onKeyDown}
      {...(exists(injectedProps.reactProps) ? injectedProps.reactProps : {})}
      className={className}
      style={{ ...noSelectStyles, ...style }}
    >
      <DescendantsProvider descendants={items} setDescendants={setItems}>
        <SelectContext.Provider
          value={{
            isOpen,
            setIsOpen,
            buttonRef,
            targetRect,
            rootClassName: className,
            selected,
            onSelect: selectAndClose,
            disabled: state === InteractionState.Disabled,
            focusedOption,
            menuRef,
            menuRect,
            addSpacing: props.addSpacing,
          }}
        >
          {renderChildren(props.children, values)}
        </SelectContext.Provider>
      </DescendantsProvider>
    </div>
  );
}
export function SelectOptionRoot(props) {
  const ref = useRef();
  const {
    disabled,
    selected,
    onSelect,
    focusedOption,
    menuRect,
    menuRef,
  } = useContext(SelectContext);
  const { state, handlers, setFocused } = useEventHandlers({
    ref,
    ...props,
    disabled: disabled || props.disabled,
    onClick: () => onSelect(props.value),
  });
  const itemDisabled = state === InteractionState.Disabled;
  const index = useDescendant({
    element: ref.current,
    value: props.value,
    disabled: itemDisabled,
  });
  const isSelected = selected === props.value;
  const isFocused = index === focusedOption;
  const {
    style,
    injectedProps,
    className,
    tabIndex,
    testId,
    innerRef,
    values,
  } = useRootProps({ ...props, selected: isSelected }, state);
  const noSelectStyles = {
    cursor: "pointer",
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const optionRect = useRect(ref);
  const maybeScrollIntoView = useCallback(() => {
    if (optionRect.top - menuRef.current.scrollTop - menuRect.top < 0) {
      ref.current.scrollIntoView();
    } else if (
      menuRect.bottom + menuRef.current.scrollTop - optionRect.bottom <
      0
    ) {
      ref.current.scrollIntoView(false);
    }
  }, [menuRef, optionRect, menuRect]);
  useEffect(() => {
    if (isFocused) {
      setFocused(true);
      maybeScrollIntoView();
    } else {
      setFocused(false);
    }
  }, [isFocused, maybeScrollIntoView, setFocused]);
  return (
    <div
      id={`option-${index}`}
      tabIndex={tabIndex}
      ref={combineRef(innerRef, ref)}
      role="option"
      aria-selected={isSelected}
      data-testid={testId}
      {...handlers}
      {...(exists(injectedProps.reactProps) ? injectedProps.reactProps : {})}
      className={className}
      style={{ ...noSelectStyles, ...style }}
    >
      {renderChildren(props.children, values)}
    </div>
  );
}
